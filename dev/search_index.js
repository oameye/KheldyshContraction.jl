var documenterSearchIndex = {"docs":
[{"location":"conventions/#Keldysh-Schwinger-field-theory-conventions","page":"Keldysh Conventions","title":"Keldysh-Schwinger field theory conventions","text":"","category":"section"},{"location":"conventions/#System","page":"Keldysh Conventions","title":"System","text":"","category":"section"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"beginaligned\nS  leftpsi_+left(psi_+right)^* psi_-left(psi_-right)^*right\n =int mathrmd^d x mathrmd t^prime \nleft(psi_+right)^*lefti partial_t+D nabla^2-V(x)right psi_+ -left(psi_-right)^*lefti partial_t+D nabla^2-V(x)right psi_-\n\n\nquadquadquadquadquadquadquadquadquadquadquadquadquadquad+ileftL_+left(L_-right)^*-frac12left(left(L_+right)^* L_+-left(L_-right)^* L_-right)right\nendaligned","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"with psi_+ and psi_- are the bosonic fields on the forward (+) and on backward (-) contour.","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"We can write this in the Retarded-Advanced-Keldysh (RAK) basis by defining psi_c = (psi_+ + psi_-)sqrt2 and psi_1 = (psi_+ - psi_-)sqrt2. The diffusion part of the action is then","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"S_mathrmdiff^R A K=int d t d^d xleftbarpsi_qlefti partial_t+D nabla^2-V(vecx)right psi_c+barpsi_clefti partial_t+D nabla^2-V(vecx)right psi_qright","category":"page"},{"location":"conventions/#Green's-functions","page":"Keldysh Conventions","title":"Green's functions","text":"","category":"section"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"beginaligned\nhatG^R A Kleft(x_1 x_2right)\n=left(beginarrayccG^Kleft(x_1 x_2right)  G^Rleft(x_1 x_2right)  G^Aleft(x_1 x_2right)  0endarrayright) \n=-ileft(beginarrayccleftlanglephi_cleft(x_1right) barphi_cleft(x_2right)rightrangle  leftlanglephi_cleft(x_1right) barphi_qleft(x_2right)rightrangle  leftlanglephi_qleft(x_1right) barphi_cleft(x_2right)rightrangle  leftlanglephi_qleft(x_1right) barphi_qleft(x_2right)rightrangleendarrayright)\nendaligned","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"Two point dressed Green's function G^mu nu labelled by indices mu=cq and nu=cq is defined as","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"i G^mu nuleft(x_1 x_2right)=int mathcalDleftphi_c barphi_c phi_q barphi_qright phi_muleft(x_1right) barphi_nuleft(x_2right) e^i S_0+i S_mathrmint","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"with S_mathrmint = int d^dx d t mathcalL_mathrmint the interaction part of the action.","category":"page"},{"location":"conventions/#Perturbation-theory","page":"Keldysh Conventions","title":"Perturbation theory","text":"","category":"section"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"beginaligned\n i G^mu nuleft(x_1 x_2right)=int mathcalDleftphi_c barphi_c phi_q barphi_qright phi_muleft(x_1right) barphi_nuleft(x_2right) sum_k=0^infty fraci^k S_mathrmint^kk e^i S_0=   quad=i G_0^mu nuleft(x_1 x_2right)+i int d^d y d t_yleftlanglephi_muleft(x_1right) barphi_nuleft(x_2right) mathcalL_mathrmint(y)rightrangle_0+sum_k=2^inftyleftlanglephi_muleft(x_1right) barphi_nuleft(x_2right) fraci^k S_mathrmint^kkrightrangle_0 \nendaligned","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"The perturbative expansion of the Green's function will have the following structure","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"hatG=hatG_0+hatG_0 circ hatSigma circ hatG_0+hatG_0 circ hatSigma circ hatG_0 circ hatSigma circ hatG_0+ldots=hatG_0+hatG_0 circ hatSigma circ hatG","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"where circ is the space-time convolution Keldysh-matrix multiplication and the self-energy hatSigma is defined as","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"hatSigmaleft(y_1 y_2right)=left(beginarraycc0  Sigma^Aleft(y_1 y_2right)  Sigma^Rleft(y_1 y_2right)  Sigma^Kleft(y_1 y_2right)endarrayright)","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"This will give us the Dyson equation","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"hatG_0^-1 -hatSigma hatG=mathbb1","category":"page"},{"location":"typesystem/#Making-symbolic-quantum-field-algebra","page":"Symbolic fields","title":"Making symbolic quantum field algebra","text":"","category":"section"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"The implemented Computer Algebra System (CAS) for the quantum fields is build using SymbolicUtils.jl and TermInterface.jl:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"SymbolicUtils.jl is a utility library for symbolic computation in Julia. It provides a set of tools for manipulating and transforming symbolic expressions, including support for rule-base algebraic operations, simplification, and pattern matching.\nTermInterface.jl is the package that defines the common interface for defining symbolic expressions. It allows users to define their own types and \"define\" them as symbols of an algebra.","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"Using these packages, we can define the algebra of quantum fields in a symbolic way. For this we proposed the type hierarchy:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"using GraphRecipes, Plots, KeldyshContraction, Random\nRandom.seed!(1) # hide\ntheme(:dracula) # hide\nplot(\n  KeldyshContraction.QField;\n  method=:tree, fontsize=10, markersize = 0.12, nodeshape=:ellipse\n)","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"KeldyshContraction.QSym will be abstract type representing the individual field of type Destroy and Create. KeldyshContraction.QTerm will represent the terms of the algebra, which are the products and sum of the fields. The type naming and hierarchy is heavily inspired by the implementation in QuantumCumulants.jl.","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"QSym can then have additional properties to make it Keldsysh-specific type fields. In the package this is done by adding fields to Create and Destroys using Enum objects:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"KeldyshContraction.KeldyshContour - the Keldysh contour of the field, which can be either KeldyshContour.Quantum or KeldyshContour.Classical.\nKeldyshContraction.Regularisation - the tadpole regularisation of the field, which can be either Regularisation.Zero, Regularisation.Plus or Regularisation.Minus.\nKeldyshContraction.AbstractPosition - the position of the field, which can be either Position.In, Position.Out or Position.Bulk.","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"To make our quantum field types work with the symbolic algebra system, we need to implement several interface functions from SymbolicUtils.jl and TermInterface.jl:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"using KeldyshContraction: SymbolicUtils, TermInterface\n\n@qfields ϕ::Destroy(Classical)\n\nTermInterface.head(ϕ) = :call\nSymbolicUtils.iscall(ϕ) = false\nSymbolicUtils.iscall(ϕ*ϕ) = true\nTermInterface.metadata(ϕ) = nothing\nSymbolicUtils.symtype(ϕ) = Destroy{Classical, KeldyshContraction.Zero, Nothing} \n(one(ϕ), zero(ϕ)) = (1, 0)","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"The key interfaces are:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"head: Defines how the expression should be interpreted (:call indicates function application)\niscall: Specifies which types represent function calls (QTerm types) vs atomic symbols (QSym types)\nmetadata: Allows attaching additional information to terms in this package is not used and set to nothing","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"For type promotion during operations, we implement:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"# Type promotion rules for operations like +, -, *, /, //, \\, ^\nSymbolicUtils.promote_symtype(::typeof(+), T::Type{<:QField}, S::Type{<:QField}) = promote_type(T, S)\nSymbolicUtils.promote_symtype(::typeof(*), T::Type{<:QField}, S::Type{<:Number}) = T","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"These implementations allow our quantum field types to:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"Be recognized as symbolic terms\nParticipate in algebraic operations\nFollow proper type promotion rules\nHandle basic mathematical concepts like identities and zeros","category":"page"},{"location":"#KeldyshContraction.jl","page":"Home","title":"KeldyshContraction.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: docs) (Image: codecov) (Image: Benchmarks)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Code Style: Blue) (Image: Aqua QA) (Image: jet)","category":"page"},{"location":"","page":"Home","title":"Home","text":"KeldyshContraction.jl is a package for the symbolic derivation of the two-point correlator diagrams in Keldysh-Schwinger field theory. The symbolic quantum field theory algebra is implemented using SymbolicUtils.jl and TermInterface.jl of the JuliaSymbolic ecosystem. The typesystem has been heavily inspired by the second quantization algebra defined in QuantumCumulants.jl. For more details on the implementation see the \"symbolic quantum field algebra\" documentation page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In developing this package, the work SciPost Phys. Core 8, 014 (2025) symbolic quantum field algebra was used extensively. Hence, the corresponding conventions and notation are used in this package.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Pages = [\"API.md\"]\nDepth = 2:3","category":"page"},{"location":"API/#KeldyshContraction","page":"API","title":"KeldyshContraction","text":"KeldyshContraction.jl\n\n(Image: docs) (Image: codecov) (Image: Benchmarks)\n\n(Image: Code Style: Blue) (Image: Aqua QA) (Image: jet)\n\nKeldyshContraction.jl is a package for the symbolic derivation of the two-point correlator diagrams in Keldysh-Schwinger field theory. The symbolic quantum field theory algebra is implemented using SymbolicUtils.jl and TermInterface.jl of the JuliaSymbolic ecosystem. The typesystem has been heavily inspired by the second quantization algebra defined in QuantumCumulants.jl. For more details on the implementation see the \"symbolic quantum field algebra\" documentation page.\n\nIn developing this package, the work SciPost Phys. Core 8, 014 (2025) symbolic quantum field algebra was used extensively. Hence, the corresponding conventions and notation are used in this package.\n\n\n\n\n\n","category":"module"},{"location":"API/#Field-Types","page":"API","title":"Field Types","text":"","category":"section"},{"location":"API/#Individual-Fields","page":"API","title":"Individual Fields","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"using Term, KeldyshContraction # hide\nTerm.typestree(KeldyshContraction.QSym) # hide","category":"page"},{"location":"API/#KeldyshContraction.QField","page":"API","title":"KeldyshContraction.QField","text":"QField\n\nAbstract type representing any expression involving Fields.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.QSym","page":"API","title":"KeldyshContraction.QSym","text":"QSym <: QField\n\nAbstract type representing fundamental Field types.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.Create","page":"API","title":"KeldyshContraction.Create","text":"Create <: QSym\n\nBosonic field representing the quantum field creation operator.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.Destroy","page":"API","title":"KeldyshContraction.Destroy","text":"Destroy <: QSym\n\nBosonic field representing the quantum field annihilation operator.\n\n\n\n\n\n","category":"type"},{"location":"API/#Field-Properties","page":"API","title":"Field Properties","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"The field properties are determined by the Enum objects:","category":"page"},{"location":"API/#KeldyshContraction.KeldyshContour","page":"API","title":"KeldyshContraction.KeldyshContour","text":"KeldyshContour `Quantum` `Classical`\n\nKeldysh contour enum for the Keldysh quantum field. The Keldysh contour is used to distinguish the field on quantum and classical contour.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.Regularisation","page":"API","title":"KeldyshContraction.Regularisation","text":"Regularisation `Plus` `Zero` `Minus`\n\nRegularisation enum for the Keldysh quantum field. The regularisation is used to perform tadpole regularisation during the Wick contraction.\n\n\n\n\n\n","category":"type"},{"location":"API/","page":"API","title":"API","text":"And the position of the field is determined by the AbstractPosition object:","category":"page"},{"location":"API/","page":"API","title":"API","text":"using Term, KeldyshContraction # hide\nTerm.typestree(KeldyshContraction.Bulk) # hide","category":"page"},{"location":"API/#KeldyshContraction.AbstractPosition","page":"API","title":"KeldyshContraction.AbstractPosition","text":"abstract type AbstractPosition\n\nAbstract Position type for the Keldysh quantum field. The position is used to determine the coordinate of the field during the wick contraction.\n\nAbstractPosition has subtypes:\n\nIn\nOut\nBulk.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.In","page":"API","title":"KeldyshContraction.In","text":"struct In <: KeldyshContraction.AbstractPosition\n\nThe In singleton to mark a field the incoming field.\n\nSee also: Out, Bulk.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.Out","page":"API","title":"KeldyshContraction.Out","text":"struct Out <: KeldyshContraction.AbstractPosition\n\nThe Out singleton to mark a field the outgoing field.\n\nSee also: In, Bulk.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.Bulk","page":"API","title":"KeldyshContraction.Bulk","text":"struct Bulk <: KeldyshContraction.AbstractPosition\n\nThe Bulk struct to mark a field relies in the bulk of a feyman diagram. This means the field will contribute to the self-energy (SelfEnergy.\n\nSee also: In, Out.\n\n\n\n\n\n","category":"type"},{"location":"API/#Field-Constructors","page":"API","title":"Field Constructors","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"It is expected to create the fields using the Create and Destroy constructors, together with the @qfields macro.","category":"page"},{"location":"API/#KeldyshContraction.@qfields","page":"API","title":"KeldyshContraction.@qfields","text":"@qfields\n\nConvenience macro for the construction of fields.\n\nExamples\n\njulia> using KeldyshContraction: Classical, Quantum\n\njulia> @qnumbers ψ::Destroy(Classical)\n(ψ,)\n\n\n\n\n\n","category":"macro"},{"location":"API/","page":"API","title":"API","text":"The created fields are callable to change a property of the individual fields:","category":"page"},{"location":"API/","page":"API","title":"API","text":"using KeldyshContraction\nusing KeldyshContraction: position\n\n@qfields ϕ::Destroy(Classical) \n\nposition(ϕ)","category":"page"},{"location":"API/#Field-Algebra","page":"API","title":"Field Algebra","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"using Term, KeldyshContraction # hide\nTerm.typestree(KeldyshContraction.QTerm) # hide","category":"page"},{"location":"API/#KeldyshContraction.QTerm","page":"API","title":"KeldyshContraction.QTerm","text":"QTerm <: QField\n\nAbstract type representing noncommutative expressions.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.QMul","page":"API","title":"KeldyshContraction.QMul","text":"struct QMul{M, T} <: KeldyshContraction.QTerm\n\nRepresent a multiplication involving quantum fields  of QSym types.\n\narg_c: The commutative prefactor.\nargs_nc: A vector containing all QSym types.\nmetadata: The metadata associated with the term. Should default to nothing.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.QAdd","page":"API","title":"KeldyshContraction.QAdd","text":"QAdd <: QTerm\n\nRepresent an addition involving QField and other types.\n\n\n\n\n\n","category":"type"},{"location":"API/","page":"API","title":"API","text":"The properties of the expression can be checked using:","category":"page"},{"location":"API/#KeldyshContraction.isbulk","page":"API","title":"KeldyshContraction.isbulk","text":"isbulk(q::QTerm)\n\nChecks if a term is in the bulk. A term is bulk if it has no In or Out position fields (AbstractPosition).\n\n\n\n\n\n","category":"function"},{"location":"API/#KeldyshContraction.is_conserved","page":"API","title":"KeldyshContraction.is_conserved","text":"is_conserved(a::QTerm)\n\nChecks if an expression [QTerm])(@ref) is conserved. A conserved expression is one that has equal numbers of creation and annihilation operators.\n\nSee also: is_physical\n\n\n\n\n\n","category":"function"},{"location":"API/#KeldyshContraction.is_physical","page":"API","title":"KeldyshContraction.is_physical","text":"is_physical(a::QTerm)\n\nChecks if an expression [QTerm])(@ref) is physical. A physical expression is one that if it has an In position field it also has an Out position field and vice versa ([Position])(@ref). Furthermore, In position field can only creation fields (Create) and Out position field can only have annihilation fields (Destroy).\n\nSee also: is_conserved\n\n\n\n\n\n","category":"function"},{"location":"API/#Systems","page":"API","title":"Systems","text":"","category":"section"},{"location":"API/#KeldyshContraction.InteractionLagrangian","page":"API","title":"KeldyshContraction.InteractionLagrangian","text":"struct InteractionLagrangian{T, pos}\n\nRepresents an interaction Lagrangian\n\nFields\n\nlagrangian: The Lagrangian expression as a QTerm\nqfield: The quantum field destruction operator\ncfield: The classical field destruction operator\n\nConstructor\n\nConstructs an InteractionLagrangian from a given QTerm expression.\n\nRequirements\n\nThe constructor enforces several constraints on the input expression and throws AssertionError if any of them are not met:\n\nMust be a bulk term (isbulk)\nMust be conserved (is_conserved)\nMust be physical (is_physical)\nCan only contain up to two different fields\nFields must have opposite contours\n\n\n\n\n\n","category":"type"},{"location":"API/#Wick-Contraction","page":"API","title":"Wick Contraction","text":"","category":"section"},{"location":"API/#KeldyshContraction.wick_contraction","page":"API","title":"KeldyshContraction.wick_contraction","text":"wick_contraction(expr::QTerm)\n\nCompute all possible Wick contractions of quantum fields in the expression expr.\n\nWick contractions decompose products of quantum field operators into sums of products of propagators (two-point correlation functions). The rules of the contraction are:\n\nConservation (equal numbers of creation/annihilation operators)\nPhysicality (proper time ordering)\nNo quantum-quantum contractions\nIf the fields have a Regularisation applied, the contractions are regularised. The Regularisation property is set to zero after the reguralisation.\n\nThe function handles two types of inputs:\n\nQAdd: Distributes the contraction over sums\nQMul: Contracts products of fields into propagators\n\nThe function returns a new expression of propagators of type SymbolicUtils.Symbol.\n\n\n\n\n\n","category":"function"},{"location":"API/#Propagator","page":"API","title":"Propagator","text":"","category":"section"},{"location":"API/#KeldyshContraction.Propagator","page":"API","title":"KeldyshContraction.Propagator","text":"struct Propagator{T} <: Number\n\nSymbolic number representing the Propagator of two fields ϕ and ψ. By convention apropagator is shown as G(ϕ, ψ) with ψ the incoming Create field  and ϕ the outgoing Destroy field.\n\nSee also: propagator\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.PropagatorType","page":"API","title":"KeldyshContraction.PropagatorType","text":"PropagatorType `Keldysh`, `Advanced`, `Retarded`\n\nThe type of propagator taken of two fields with the x-y Contour where x is the Contour of the Destroy field and y the contour of the Create field.\n\nKeldysh propagator of a Classical-Classical contour\nAdvanced propagator of a Quantum-Classical contour\nRetarded propagator of a Classical-Quantum contour\n\nThe Quantum-Quantum propagator should always be zero.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.propagator","page":"API","title":"KeldyshContraction.propagator","text":"propagator(\n    x::KeldyshContraction.QSym,\n    y::KeldyshContraction.QSym\n) -> Any\n\n\nCreate the Keldysh two-point green's functions over two field ψ and ϕ:\n\nG(x_1x_2) = -i langle phi(x_1) overlinepsi(x_2) rangle\n\nHere ψ is the incoming Create field at coordinate x_2=(vecx_1 t_1) and ψ the outgoing Destroy field at coordinate x_2=(vecx_2 t_2). The created propagator will be a symbolic function of SymbolicUtils.FnType which maps Tuple Tuple{QSym,QSym} to SymbolicUtils.BasicSymbolic{Propagator{T}} where T is the type PropagatorType.\n\nThe name of the symbolic function is :avg and is reserved as it is used internally for printing.\n\n\n\n\n\n","category":"function"},{"location":"API/#KeldyshContraction.DressedPropagator","page":"API","title":"KeldyshContraction.DressedPropagator","text":"struct DressedPropagator{Tk, Tr, Ta}\n\nA structure representing dressed propagator in the Retarded-Advanced-Keldysh basis (PropagatorType).\n\nFields\n\nkeldysh: The Keldysh component of the propagator\nretarded: The retarded component of the propagator\nadvanced: The advanced component of the propagator\n\nwhere it assumed that the fields are of type Union{SymbolicUtils.Symbolic{<:Number}, Number}.\n\nConstructor\n\nConstructs a DressedPropagator with the given Keldysh, retarded, and advanced components.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.matrix-Tuple{DressedPropagator}","page":"API","title":"KeldyshContraction.matrix","text":"matrix(G::DressedPropagator)\n\nReturns the matrix representation of the dressed propagator G in the Retarded-Advanced-Keldysh basis.\n\nhatGleft(x_1 x_2right)\n=left(\nbeginarraycc\nG^Kleft(x_1 x_2right)  G^Rleft(x_1 x_2right) \nG^Aleft(x_1 x_2right)  0\nendarray\nright)\n\n\n\n\n\n","category":"method"},{"location":"API/#Self-Energy","page":"API","title":"Self-Energy","text":"","category":"section"},{"location":"API/#KeldyshContraction.SelfEnergy","page":"API","title":"KeldyshContraction.SelfEnergy","text":"struct SelfEnergy{Tk, Tr, Ta}\n\nA struct representing the self-energy components in the Retarded-Advance-Keldysh basis (PropagatorType). The self-energy is divided into three components: Keldysh, retarded, and advanced.\n\nFields\n\nkeldysh: The Keldysh component of the self-energy.\nretarded:  The retarded component of the self-energy.\nadvanced: The advanced component of the self-energy.\n\nwhere it assumed that the fields are of type Union{SymbolicUtils.Symbolic{<:Number}, Number}.\n\nConstructor\n\nConstructs a SelfEnergy object from a DressedPropagator. The self-energy is computed based on the Keldysh Green's function (G.keldysh) and expanded into its quantum-quantum (qq), classical-quantum (cq), and quantum-classical (qc) components.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.matrix-Tuple{SelfEnergy}","page":"API","title":"KeldyshContraction.matrix","text":"matrix(Σ::SelfEnergy)\n\nReturns the matrix representation of the self energy Σ in the Retarded-Advanced-Keldysh basis.\n\nhatSigmaleft(y_1 y_2right)=\nleft(beginarraycc0  Sigma^Aleft(y_1 y_2right) \nSigma^Rleft(y_1 y_2right)  Sigma^Kleft(y_1 y_2right)\nendarray\nright)\n\n\n\n\n\n","category":"method"}]
}
