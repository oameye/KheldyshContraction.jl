var documenterSearchIndex = {"docs":
[{"location":"conventions/#Keldysh-Schwinger-Field-Theory-Conventions","page":"Keldysh Conventions","title":"Keldysh-Schwinger Field Theory Conventions","text":"","category":"section"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"This document outlines the conventions used in Keldysh-Schwinger field theory, including the system's action, Green's functions, and the self-consistent Born approximation. These conventions are essential for understanding the mathematical framework and methods employed in the package.","category":"page"},{"location":"conventions/#System","page":"Keldysh Conventions","title":"System","text":"","category":"section"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"The system is described by the action S, which governs the dynamics of the bosonic fields psi_+ and psi_- on the forward (+) and backward (-) contours, respectively. The action is given by:","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"beginaligned\nS  leftpsi_+left(psi_+right)^* psi_-left(psi_-right)^*right\n =int mathrmd^d x mathrmd t^prime \nleft(psi_+right)^*lefti partial_t+D nabla^2-V(x)right psi_+ -left(psi_-right)^*lefti partial_t+D nabla^2-V(x)right psi_-\n\n\nquadquadquadquadquadquadquadquadquadquadquadquadquadquad+ileftL_+left(L_-right)^*-frac12left(left(L_+right)^* L_+-left(L_-right)^* L_-right)right\nendaligned","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"Here, psi_+ and psi_- are the bosonic fields on the forward (+) and backward (-) contours, respectively.","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"We can rewrite this in the Retarded-Advanced-Keldysh (RAK) basis by defining:","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"psi_c = (psi_+ + psi_-)sqrt2\n(classical field)\npsi_q = (psi_+ - psi_-)sqrt2\n(quantum field)","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"In this basis, the diffusion part of the action becomes:","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"S_mathrmdiff^R A K=int d t d^d xleftbarpsi_qlefti partial_t+D nabla^2-V(vecx)right psi_c+barpsi_clefti partial_t+D nabla^2-V(vecx)right psi_qright","category":"page"},{"location":"conventions/#Green's-Functions","page":"Keldysh Conventions","title":"Green's Functions","text":"","category":"section"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"Green's functions describe the propagation of fields and encode information about the system's response to perturbations. In the RAK basis, the Green's function is represented as a matrix:","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"beginaligned\nhatG^R A Kleft(x_1 x_2right)\n=left(beginarrayccG^Kleft(x_1 x_2right)  G^Rleft(x_1 x_2right)  G^Aleft(x_1 x_2right)  0endarrayright) \n=-ileft(beginarrayccleftlanglephi_cleft(x_1right) barphi_cleft(x_2right)rightrangle  leftlanglephi_cleft(x_1right) barphi_qleft(x_2right)rightrangle  leftlanglephi_a cornerstone","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"Here, G^R, G^A, and G^K are the retarded, advanced, and Keldysh Green's functions, respectively.","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"The two-point dressed Green's function G^mu nu, labeled by indices mu=cq and nu=cq, is defined as:","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"i G^mu nuleft(x_1 x_2right)=int mathcalDleftphi_c barphi_c phi_q barphi_qright phi_muleft(x_1right) barphi_nuleft(x_2right) e^i S_0+i S_mathrmint","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"Here, S_mathrmint = int d^dx d t mathcalL_mathrmint is the interaction part of the action.","category":"page"},{"location":"conventions/#Self-Consistent-Born-Approximation","page":"Keldysh Conventions","title":"Self-Consistent Born Approximation","text":"","category":"section"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"The self-consistent Born approximation is a perturbative method used to compute the Green's function by expanding it in terms of the interaction part of the action. The expansion is given by:","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"beginaligned\n i G^mu nuleft(x_1 x_2right)=int mathcalDleftphi_c barphi_c phi_q barphi_qright phi_muleft(x_1right) barphi_nuleft(x_2right) sum_k=0^infty fraci^k S_mathrmint^kk e^i S_0=  \n quad=i G_0^mu nuleft(x_1 x_2right)+i int d^d y d t_yleftlanglephi_muleft(x_1right) barphi_nuleft(x_2right) mathcalL_mathrmint(y)rightrangle_0+sum_k=2^inftyleftlanglephi_muleft(x_1right) barphi_nuleft(x_2right) fraci^k S_mathrmint^kkrightrangle_0 \nendaligned","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"The perturbative expansion of the Green's function has the structure:","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"hatG=hatG_0+hatG_0 circ hatSigma circ hatG_0+hatG_0 circ hatSigma circ hatG_0 circ hatSigma circ hatG_0+ldots=hatG_0+hatG_0 circ hatSigma circ hatG","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"Here, circ denotes space-time convolution and Keldysh-matrix multiplication. The self-energy hatSigma is defined as:","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"hatSigmaleft(y_1 y_2right)=left(beginarraycc0  Sigma^Aleft(y_1 y_2right)  Sigma^Rleft(y_1 y_2right)  Sigma^Kleft(y_1 y_2right)endarrayright)","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"This leads to the Dyson equation, which relates the full Green's function hatG to the non-interacting Green's function hatG_0 and the self-energy hatSigma:","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"hatG_0^-1 -hatSigma hatG=mathbb1","category":"page"},{"location":"conventions/","page":"Keldysh Conventions","title":"Keldysh Conventions","text":"The Dyson equation is central of many-body physics, providing a framework for systematically incorporating interactions.","category":"page"},{"location":"examples/elastic_two_body/#Elastic-Two-Body-Scattering","page":"Elastic two body scattering","title":"Elastic Two Body Scattering","text":"","category":"section"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"using KeldyshContraction","category":"page"},{"location":"examples/elastic_two_body/#System","page":"Elastic two body scattering","title":"System","text":"","category":"section"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"The interaction action of elastic two body scattering, is defined as","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"S_mathrmint = -fracg2 int d^d x  (barphi^+phi^+)^2 - (barphi^-phi^-)^2 ","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"Above interaction can typically represent s-wave scattering of bosons.","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"In the RAK basis, this gives","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"S_mathrmint = -fracg2 int d^d x  (barphi^cbarphi^qphi^cphi^c)\n+(barphi^cbarphi^qphi^qphi^q) + cc","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"Let us represent this quantum and classical field inside the KeldyshContraction package and define the interaction Lagrangian:","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"@qfields c::Destroy(Classical) q::Destroy(Quantum)\nelasctic2boson = 0.5 * (c^2 + q^2) * c' * q' + 0.5 * c * q * ((c')^2 + (q')^2)\nL_int = InteractionLagrangian(elasctic2boson)","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"A good check if the interaction Lagrangian is a valid physical process, is to check if the normalization identity Z=1 holds. We can do this perturbatively in g by expanding exp(i S_mathrmint)  and showing the average of the linear part of the system is zero","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"langle S_mathrmintrangle =  langle S_mathrmint^2rangle  =ldots = 0","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"In computing the average, one performs Wick contractions to describe the average in terms of the two-point correlators of the linear part of the system.","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"In the package we can do this as follows:","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"wick_contraction(elasctic2boson)","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"However, to show that these diagrams cancel out, we need to apply to condition G^R = - G^A. Inside the package we do this by","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"KeldyshContraction.advanced_to_retarded(wick_contraction(elasctic2boson))","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"Similarly, we can compute the next orders.","category":"page"},{"location":"examples/elastic_two_body/#First-order-Green's-function","page":"Elastic two body scattering","title":"First order Green's function","text":"","category":"section"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"To compute the two point Green's functions of the interacting system, we can apply  self-consistent perturbation theory. By again expanding in g we can write","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"beginaligned\n i G^mu nuleft(x_1 x_2right)=int mathcalDleftphi_c barphi_c phi_q barphi_qright phi_muleft(x_1right) barphi_nuleft(x_2right) sum_k=0^infty fraci^k S_mathrmint^kk e^i S_0= \n quad=i G_0^mu nuleft(x_1 x_2right)+i int d^d y d t_yleftlanglephi_muleft(x_1right) barphi_nuleft(x_2right) mathcalL_mathrmint(y)rightrangle_0+sum_k=2^inftyleftlanglephi_muleft(x_1right) barphi_nuleft(x_2right) fraci^k S_mathrmint^kkrightrangle_0 \nendaligned","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"So we can compute the first order Green's function correction G_{(1)} by computing the Wick contraction of the interaction Lagrangian","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"GF = wick_contraction(L_int)","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"Here, the simplification of the advanced to retarded propagator is done internally.","category":"page"},{"location":"examples/elastic_two_body/#Self-Energy","page":"Elastic two body scattering","title":"Self-Energy","text":"","category":"section"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"Often we are interested in the self-energy of the system, which is defined as the set of irreduciable diagrams. Inside the package we can compute these to an order g by","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"Σ = SelfEnergy(GF)","category":"page"},{"location":"examples/elastic_two_body/#Transport","page":"Elastic two body scattering","title":"Transport","text":"","category":"section"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"The self-energy can be used to compute derive a kinetic equation for the system. In doing this one compute the so-called collision integral, which is given by","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"I _mathrmcoll= i Σ^K(x p) +  F (x p) (Σ^R(x p)-Σ^A(x p))","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"Here, F is the bosonic distribution function of the system. However, from above calculation we find that i Σ^K(x p) = 0 and Σ^R(x p)=Σ^A(x p), such that the collision integral has not contribution at first order.","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"# Second order\n\nGF = wick_contraction(L_int; order=2)","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"using SymbolicUtils import KeldyshContraction as KC terms = arguments(expand(GF.keldysh))","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"bulkmultiplicity = map(terms) do term     props = KC.getpropagators(term)     vs = map(props) do p         ff = KC.fields(p)         KC.integerpositions((ff[1],ff[2]))     end     KC.bulkmultiplicity(vs) end","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"topology1 = findall(i -> i == [1], bulkmultiplicity) topology2 = findall(i -> i == [2], bulkmultiplicity) topology3 = findall(i -> i == [3], bulk_multiplicity) length(topology1) + length(topology2) + length(topology3) @show simplify.(terms[topology2])","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"order = map(terms[topology3]) do term     props = KC.getpropagators(term)     sort!(props, by=KC.position)     ptype = KC.propagatortype.(props)     Int.(ptype) end nonuniques = map(order) do v     findall(x -> isequal(x, v), order) end","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"","category":"page"},{"location":"examples/elastic_two_body/","page":"Elastic two body scattering","title":"Elastic two body scattering","text":"This page was generated using Literate.jl.","category":"page"},{"location":"typesystem/#Making-symbolic-quantum-field-algebra","page":"Symbolic fields","title":"Making symbolic quantum field algebra","text":"","category":"section"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"The implemented Computer Algebra System (CAS) for the quantum fields is build using SymbolicUtils.jl and TermInterface.jl:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"SymbolicUtils.jl is a utility library for symbolic computation in Julia. It provides a set of tools for manipulating and transforming symbolic expressions, including support for rule-base algebraic operations, simplification, and pattern matching.\nTermInterface.jl is the package that defines the common interface for defining symbolic expressions. It allows users to define their own types and \"define\" them as symbols of an algebra.","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"Using these packages, we can define the algebra of quantum fields in a symbolic way. For this we proposed the type hierarchy:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"using GraphRecipes, Plots, KeldyshContraction, Random\nRandom.seed!(1) # hide\ntheme(:dracula) # hide\nplot(\n  KeldyshContraction.QField;\n  method=:tree, fontsize=10, markersize = 0.12, nodeshape=:ellipse\n)","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"KeldyshContraction.QSym will be abstract type representing the individual field of type Destroy and Create. KeldyshContraction.QTerm will represent the terms of the algebra, which are the products and sum of the fields. The type naming and hierarchy is heavily inspired by the implementation in QuantumCumulants.jl.","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"QSym can then have additional properties to make it Keldsysh-specific type fields. In the package this is done by adding fields to Create and Destroys using Enum objects:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"KeldyshContraction.KeldyshContour - the Keldysh contour of the field, which can be either KeldyshContour.Quantum or KeldyshContour.Classical.\nKeldyshContraction.Regularisation - the tadpole regularisation of the field, which can be either Regularisation.Zero, Regularisation.Plus or Regularisation.Minus.\nKeldyshContraction.AbstractPosition - the position of the field, which can be either Position.In, Position.Out or Position.Bulk.","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"To make our quantum field types work with the symbolic algebra system, we need to implement several interface functions from SymbolicUtils.jl and TermInterface.jl:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"using KeldyshContraction: SymbolicUtils, TermInterface\n\n@qfields ϕ::Destroy(Classical)\n\nTermInterface.head(ϕ) = :call\nSymbolicUtils.iscall(ϕ) = false\nSymbolicUtils.iscall(ϕ*ϕ) = true\nTermInterface.metadata(ϕ) = nothing\nSymbolicUtils.symtype(ϕ) = Destroy{Classical, KeldyshContraction.Zero, Nothing} \n(one(ϕ), zero(ϕ)) = (1, 0)","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"The key interfaces are:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"head: Defines how the expression should be interpreted (:call indicates function application)\niscall: Specifies which types represent function calls (QTerm types) vs atomic symbols (QSym types)\nmetadata: Allows attaching additional information to terms in this package is not used and set to nothing","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"For type promotion during operations, we implement:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"# Type promotion rules for operations like +, -, *, /, //, \\, ^\nSymbolicUtils.promote_symtype(::typeof(+), T::Type{<:QField}, S::Type{<:QField}) = promote_type(T, S)\nSymbolicUtils.promote_symtype(::typeof(*), T::Type{<:QField}, S::Type{<:Number}) = T","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"These implementations allow our quantum field types to:","category":"page"},{"location":"typesystem/","page":"Symbolic fields","title":"Symbolic fields","text":"Be recognized as symbolic terms\nParticipate in algebraic operations\nFollow proper type promotion rules\nHandle basic mathematical concepts like identities and zeros","category":"page"},{"location":"#KeldyshContraction.jl","page":"Home","title":"KeldyshContraction.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: docs) (Image: codecov) (Image: Benchmarks)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Code Style: Blue) (Image: Aqua QA) (Image: jet)","category":"page"},{"location":"","page":"Home","title":"Home","text":"KeldyshContraction.jl is a package for the symbolic derivation of the two-point correlator diagrams in Keldysh-Schwinger field theory. The symbolic quantum field theory algebra is implemented using SymbolicUtils.jl and TermInterface.jl of the JuliaSymbolic ecosystem. The typesystem has been heavily inspired by the second quantization algebra defined in QuantumCumulants.jl. For more details on the implementation see the \"symbolic quantum field algebra\" documentation page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In developing this package, the work SciPost Phys. Core 8, 014 (2025) symbolic quantum field algebra was used extensively. Hence, the corresponding conventions and notation are used in this package.","category":"page"},{"location":"literature/#Relevant-Literature","page":"Literature","title":"Relevant Literature","text":"","category":"section"},{"location":"literature/","page":"Literature","title":"Literature","text":"Thompson et al. Field theory of many-body Lindbladian dynamics.\nSieberer et al. Keldysh Field Theory for Driven Open Quantum Systems\nGerbino et al. Kinetics of Quantum Reaction-Diffusion systems.\nAlex Kamenev. Field Theory of Non-Equilibrium Systems","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Pages = [\"API.md\"]\nDepth = 2:3","category":"page"},{"location":"API/#KeldyshContraction","page":"API","title":"KeldyshContraction","text":"KeldyshContraction.jl\n\n(Image: docs) (Image: codecov) (Image: Benchmarks)\n\n(Image: Code Style: Blue) (Image: Aqua QA) (Image: jet)\n\nKeldyshContraction.jl is a package for the symbolic derivation of the two-point correlator diagrams in Keldysh-Schwinger field theory. The symbolic quantum field theory algebra is implemented using SymbolicUtils.jl and TermInterface.jl of the JuliaSymbolic ecosystem. The typesystem has been heavily inspired by the second quantization algebra defined in QuantumCumulants.jl. For more details on the implementation see the \"symbolic quantum field algebra\" documentation page.\n\nIn developing this package, the work SciPost Phys. Core 8, 014 (2025) symbolic quantum field algebra was used extensively. Hence, the corresponding conventions and notation are used in this package.\n\n\n\n\n\n","category":"module"},{"location":"API/#Field-Types","page":"API","title":"Field Types","text":"","category":"section"},{"location":"API/#Individual-Fields","page":"API","title":"Individual Fields","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"using Term, KeldyshContraction # hide\nTerm.typestree(KeldyshContraction.QSym) # hide","category":"page"},{"location":"API/#KeldyshContraction.QField","page":"API","title":"KeldyshContraction.QField","text":"QField\n\nAbstract type representing any expression involving Fields.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.QSym","page":"API","title":"KeldyshContraction.QSym","text":"QSym <: QField\n\nAbstract type representing fundamental Field types.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.Create","page":"API","title":"KeldyshContraction.Create","text":"Create <: QSym\n\nBosonic field representing the quantum field creation operator.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.Destroy","page":"API","title":"KeldyshContraction.Destroy","text":"Destroy <: QSym\n\nBosonic field representing the quantum field annihilation operator.\n\n\n\n\n\n","category":"type"},{"location":"API/#Field-Properties","page":"API","title":"Field Properties","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"The field properties are determined by the Enum objects:","category":"page"},{"location":"API/#KeldyshContraction.KeldyshContour","page":"API","title":"KeldyshContraction.KeldyshContour","text":"KeldyshContour `Quantum` `Classical`\n\nKeldysh contour enum for the Keldysh quantum field. The Keldysh contour is used to distinguish the field on quantum and classical contour.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.Regularisation","page":"API","title":"KeldyshContraction.Regularisation","text":"Regularisation `Plus` `Zero` `Minus`\n\nRegularisation enum for the Keldysh quantum field. The regularisation is used to perform tadpole regularisation during the Wick contraction.\n\n\n\n\n\n","category":"type"},{"location":"API/","page":"API","title":"API","text":"And the position of the field is determined by the AbstractPosition object:","category":"page"},{"location":"API/","page":"API","title":"API","text":"using Term, KeldyshContraction # hide\nTerm.typestree(KeldyshContraction.Bulk) # hide","category":"page"},{"location":"API/#KeldyshContraction.AbstractPosition","page":"API","title":"KeldyshContraction.AbstractPosition","text":"abstract type AbstractPosition\n\nAbstract Position type for the Keldysh quantum field. The position is used to determine the coordinate of the field during the wick contraction.\n\nAbstractPosition has subtypes:\n\nIn\nOut\nBulk.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.In","page":"API","title":"KeldyshContraction.In","text":"struct In <: KeldyshContraction.AbstractPosition\n\nThe In singleton to mark a field the incoming field.\n\nSee also: Out, Bulk.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.Out","page":"API","title":"KeldyshContraction.Out","text":"struct Out <: KeldyshContraction.AbstractPosition\n\nThe Out singleton to mark a field the outgoing field.\n\nSee also: In, Bulk.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.Bulk","page":"API","title":"KeldyshContraction.Bulk","text":"struct Bulk <: KeldyshContraction.AbstractPosition\n\nThe Bulk struct to mark a field relies in the bulk of a feyman diagram. This means the field will contribute to the self-energy (SelfEnergy.\n\nSee also: In, Out.\n\n\n\n\n\n","category":"type"},{"location":"API/#Field-Constructors","page":"API","title":"Field Constructors","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"It is expected to create the fields using the Create and Destroy constructors, together with the @qfields macro.","category":"page"},{"location":"API/#KeldyshContraction.@qfields","page":"API","title":"KeldyshContraction.@qfields","text":"@qfields\n\nConvenience macro for the construction of fields.\n\nExamples\n\njulia> using KeldyshContraction: Classical, Quantum\n\njulia> @qnumbers ψ::Destroy(Classical)\n(ψ,)\n\n\n\n\n\n","category":"macro"},{"location":"API/","page":"API","title":"API","text":"The created fields are callable to change a property of the individual fields:","category":"page"},{"location":"API/","page":"API","title":"API","text":"using KeldyshContraction\nusing KeldyshContraction: position\n\n@qfields ϕ::Destroy(Classical) \n\nposition(ϕ)","category":"page"},{"location":"API/#Field-Algebra","page":"API","title":"Field Algebra","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"using Term, KeldyshContraction # hide\nTerm.typestree(KeldyshContraction.QTerm) # hide","category":"page"},{"location":"API/#KeldyshContraction.QTerm","page":"API","title":"KeldyshContraction.QTerm","text":"QTerm <: QField\n\nAbstract type representing noncommutative expressions.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.QMul","page":"API","title":"KeldyshContraction.QMul","text":"struct QMul{T<:Number} <: KeldyshContraction.QTerm\n\nRepresent a multiplication involving quantum fields  of QSym types.\n\narg_c: The commutative prefactor.\nargs_nc: A vector containing all QSym types.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.QAdd","page":"API","title":"KeldyshContraction.QAdd","text":"QAdd <: QTerm\n\nRepresent an addition involving QField and other types.\n\n\n\n\n\n","category":"type"},{"location":"API/#TermInterface.arguments-Tuple{KeldyshContraction.QMul}","page":"API","title":"TermInterface.arguments","text":"arguments(a::QMul)\n\nReturn the vector of the factors of QMul.\n\n\n\n\n\n","category":"method"},{"location":"API/#TermInterface.arguments-Tuple{KeldyshContraction.QAdd}","page":"API","title":"TermInterface.arguments","text":"arguments(a::QAdd)\n\nReturn the vector of the arguments of QAdd.\n\n\n\n\n\n","category":"method"},{"location":"API/","page":"API","title":"API","text":"The properties of the expression can be checked using:","category":"page"},{"location":"API/#KeldyshContraction.isbulk","page":"API","title":"KeldyshContraction.isbulk","text":"isbulk(q::QTerm)\n\nChecks if a term is in the bulk. A term is bulk if it has no In or Out position fields (AbstractPosition).\n\n\n\n\n\n","category":"function"},{"location":"API/#KeldyshContraction.is_conserved","page":"API","title":"KeldyshContraction.is_conserved","text":"is_conserved(a::QTerm)\n\nChecks if an expression [QTerm])(@ref) is conserved. A conserved expression is one that has equal numbers of creation and annihilation operators.\n\nSee also: is_physical\n\n\n\n\n\n","category":"function"},{"location":"API/#KeldyshContraction.is_physical","page":"API","title":"KeldyshContraction.is_physical","text":"is_physical(a::QTerm)\n\nChecks if an expression [QTerm])(@ref) is physical. A physical expression is one that if it has an In position field it also has an Out position field and vice versa ([Position])(@ref). Furthermore, In position field can only creation fields (Create) and Out position field can only have annihilation fields (Destroy).\n\nSee also: is_conserved\n\n\n\n\n\n","category":"function"},{"location":"API/#Systems","page":"API","title":"Systems","text":"","category":"section"},{"location":"API/#KeldyshContraction.InteractionLagrangian","page":"API","title":"KeldyshContraction.InteractionLagrangian","text":"struct InteractionLagrangian{T}\n\nRepresents an interaction Lagrangian\n\nFields\n\nlagrangian: The Lagrangian expression as a QTerm\nqfield: The quantum field destruction operator\ncfield: The classical field destruction operator\nposition: The position of the interaction Lagrangian\n\nConstructor\n\nConstructs an InteractionLagrangian from a given QTerm expression.\n\nRequirements\n\nThe constructor enforces several constraints on the input expression and throws AssertionError if any of them are not met:\n\nMust be a bulk term (isbulk)\nMust be conserved (is_conserved)\nMust be physical (is_physical)\nCan only contain up to two different fields\nFields must have opposite contours\n\n\n\n\n\n","category":"type"},{"location":"API/#Wick-Contraction","page":"API","title":"Wick Contraction","text":"","category":"section"},{"location":"API/#KeldyshContraction.wick_contraction","page":"API","title":"KeldyshContraction.wick_contraction","text":"wick_contraction(L::InteractionLagrangian; order=1)\n\nAll the same coordinate advanced propagators are converted to retarded propagators.\n\n\n\n\n\nwick_contraction(expr::QTerm)\n\nCompute all possible Wick contractions of quantum fields in the expression expr.\n\nWick contractions decompose products of quantum field operators into sums of products of propagators (two-point correlation functions). The rules of the contraction are:\n\nConservation (equal numbers of creation/annihilation operators)\nPhysicality (proper time ordering)\nNo quantum-quantum contractions\nIf the fields have a Regularisation applied, the contractions are regularised. The Regularisation property is set to zero after the reguralisation.\n\nThe function handles two types of inputs:\n\nQAdd: Distributes the contraction over sums\nQMul: Contracts products of fields into propagators\n\nThe function returns a new expression of propagators of type SymbolicUtils.Symbol.\n\n\n\n\n\nWe split up the fields into two groups, destroys and creates. We can can combute all possible pairs by permutating the create vector. To avoid pairing up the In() and Out() fields, we have made sure that the destroy and create vectors are ordered with the in and out fields first. Computing the permutatins in lexicographic order, we can skip the first (n-1)! permutations.\n\n\n\n\n\n","category":"function"},{"location":"API/#Propagator","page":"API","title":"Propagator","text":"","category":"section"},{"location":"API/#KeldyshContraction.Propagator","page":"API","title":"KeldyshContraction.Propagator","text":"struct Propagator{T} <: Number\n\nSymbolic number representing the Propagator of two fields ϕ and ψ. By convention apropagator is shown as G(ϕ, ψ) with ψ the incoming Create field  and ϕ the outgoing Destroy field.\n\nSee also: propagator\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.PropagatorType","page":"API","title":"KeldyshContraction.PropagatorType","text":"PropagatorType `Keldysh`, `Advanced`, `Retarded`\n\nThe type of propagator taken of two fields with the x-y Contour where x is the Contour of the Destroy field and y the contour of the Create field.\n\nKeldysh propagator of a Classical-Classical contour\nAdvanced propagator of a Quantum-Classical contour\nRetarded propagator of a Classical-Quantum contour\n\nThe Quantum-Quantum propagator should always be zero.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.propagator","page":"API","title":"KeldyshContraction.propagator","text":"propagator(\n    x::KeldyshContraction.QSym,\n    y::KeldyshContraction.QSym\n) -> Any\n\n\nCreate the Keldysh two-point green's functions over two field ψ and ϕ:\n\nG(x_1x_2) = -i langle phi(x_1) overlinepsi(x_2) rangle\n\nHere ψ is the incoming Create field at coordinate x_2=(vecx_1 t_1) and ψ the outgoing Destroy field at coordinate x_2=(vecx_2 t_2). The created propagator will be a symbolic function of SymbolicUtils.FnType which maps Tuple Tuple{QSym,QSym} to SymbolicUtils.BasicSymbolic{Propagator{T}} where T is the type PropagatorType.\n\nThe name of the symbolic function is :avg and is reserved as it is used internally for printing.\n\n\n\n\n\n","category":"function"},{"location":"API/#KeldyshContraction.DressedPropagator","page":"API","title":"KeldyshContraction.DressedPropagator","text":"struct DressedPropagator{Tk, Tr, Ta}\n\nA structure representing dressed propagator in the Retarded-Advanced-Keldysh basis (PropagatorType).\n\nFields\n\nkeldysh: The Keldysh component of the propagator\nretarded: The retarded component of the propagator\nadvanced: The advanced component of the propagator\n\nwhere it assumed that the fields are of type Union{SymbolicUtils.Symbolic{<:Number}, Number}.\n\nConstructor\n\nConstructs a DressedPropagator with the given Keldysh, retarded, and advanced components.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.matrix-Tuple{DressedPropagator}","page":"API","title":"KeldyshContraction.matrix","text":"matrix(G::DressedPropagator)\n\nReturns the matrix representation of the dressed propagator G in the Retarded-Advanced-Keldysh basis.\n\nhatGleft(x_1 x_2right)\n=left(\nbeginarraycc\nG^Kleft(x_1 x_2right)  G^Rleft(x_1 x_2right) \nG^Aleft(x_1 x_2right)  0\nendarray\nright)\n\n\n\n\n\n","category":"method"},{"location":"API/#Self-Energy","page":"API","title":"Self-Energy","text":"","category":"section"},{"location":"API/#KeldyshContraction.SelfEnergy","page":"API","title":"KeldyshContraction.SelfEnergy","text":"struct SelfEnergy{Tk, Tr, Ta}\n\nA struct representing the self-energy components in the Retarded-Advance-Keldysh basis (PropagatorType). The self-energy is divided into three components: Keldysh, retarded, and advanced.\n\nFields\n\nkeldysh: The Keldysh component of the self-energy.\nretarded:  The retarded component of the self-energy.\nadvanced: The advanced component of the self-energy.\n\nwhere it assumed that the fields are of type Union{SymbolicUtils.Symbolic{<:Number}, Number}.\n\nConstructor\n\nConstructs a SelfEnergy object from a DressedPropagator. The self-energy is computed based on the Keldysh Green's function (G.keldysh) and expanded into its quantum-quantum (qq), classical-quantum (cq), and quantum-classical (qc) components.\n\n\n\n\n\n","category":"type"},{"location":"API/#KeldyshContraction.matrix-Tuple{SelfEnergy}","page":"API","title":"KeldyshContraction.matrix","text":"matrix(Σ::SelfEnergy)\n\nReturns the matrix representation of the self energy Σ in the Retarded-Advanced-Keldysh basis.\n\nhatSigmaleft(y_1 y_2right)=\nleft(beginarraycc0  Sigma^Aleft(y_1 y_2right) \nSigma^Rleft(y_1 y_2right)  Sigma^Kleft(y_1 y_2right)\nendarray\nright)\n\n\n\n\n\n","category":"method"}]
}
